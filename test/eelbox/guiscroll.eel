/////////////////////////////////////////////////////
// guiscroll.eel - EBGUI scroll test
// Copyright 2006-2007, 2009, 2011 David Olofson
/////////////////////////////////////////////////////

import "SDL" as SDL;
import "text" as text;
import "ebgui" as ebgui;
import "math";


export function main<args>
{
	local do_exit = false;
	local bpp = 0;
	local flags = SDL.SWSURFACE | SDL.RESIZABLE;
	local screen = SDL.SetVideoMode(640, 480, bpp, flags);
	SDL.EnableKeyRepeat(250, 30);
//	local font = text.Open("microfont_sh.png");
//	font:Offset(-1, 1);
	SDL.SetCaption("EBGUI Scroll Test", args[0]);

	ebgui.Open(screen);
	local gui = ebgui.Root();
	gui:SetAlign("grid", 2, 2, [62, 2], [46, 2]);

	local sb, gui.scrollbox = ebgui.Panel(gui, "depression");
	sb.border = 10;
	sb:SetAlign("relative", 0, 0);
	sb.yslider = ebgui.VSlider(gui,
			procedure (self, v)
			{
				self.parent.scrollbox:SetScrollPos(nil, v);
			});
	sb.xslider = ebgui.HSlider(gui,
			procedure (self, v)
			{
				self.parent.scrollbox:SetScrollPos(v, nil);
			});

// TODO: Somehow hook into the aligment system and reset
// TODO: scroll positions and gray out sliders as needed.
// TODO: Implement optional standard sliders in Panel?

	for local i = 0, 255
	{
		local lb = ebgui.Button(gui.scrollbox, (string)i);
		local xx = i % 16;
		local yy = (integer)(i / 16);
		lb.logicrect.(x, y, w, h) = xx * 192, yy * 128, 128, 64;
	}
	
	while not do_exit
	{
		local ev = SDL.PollEvent();
		if not ev
		{
			local dr = array [];
			ebgui.Refresh(dr);
			if sizeof dr
				SDL.Update(dr);
			ev = SDL.WaitEvent();
		}
		switch ev.type
		  case SDL.KEYDOWN
		  {
			switch ev.sym
			  case SDL.KESCAPE
				do_exit = true;
			  default
				ebgui.Dispatch(ev);
		  }
		  case SDL.VIDEOEXPOSE
			ebgui.Invalidate();
		  case SDL.VIDEORESIZE
		  {
			screen = SDL.SetVideoMode(ev.w, ev.h, bpp, flags);
			gui:SetRect(SDL.Rect [0, 0, ev.(w, h)]);
			ebgui.Invalidate();
		  }
		  case SDL.QUIT
			do_exit = true;
		  default
			ebgui.Dispatch(ev);
	}
	ebgui.Close();
	return 0;
}
