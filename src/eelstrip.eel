//////////////////////////////////////////////////////////
// Strip EEL source files of all comments and formatting
// Copyright (C) 2010, 2011 David Olofson
//////////////////////////////////////////////////////////
//
// TODO:
//	* Don't touch string contents!!!
//	* In-place file processing! (.eel ==> .ess)
//	* Recursize directory processing!
//	* Keyword tokenization
//		* Space before and after keywords when detokenizing?
//	* Operator tokenization
//	* Encode line number info
//

import "io", "dir";

constant ESS_FIRST_TOKEN = 128;

static tokens = [
	"include", "import", "as", "end",

	"return", "if", "else", "switch", "case", "default",
	"for", "do", "while", "until", "break", "continue", "repeat",

	"try", "untry", "except", "throw", "retry", "exception",

	"local", "static", "upvalue", "export", "shadow", "constant",

	"procedure",

	"true", "false", "nil",

	"arguments", "tuples", "specified"
];
static tokentab;

procedure strip(f, out, newlines)
{
	function is_whitespace(c)
	{
		switch c
		  case ' ', '\t', '\r', '\n'
			return true;
		  default
			return false;
	}
	local lastout = nil;
	try while true
	{
		local b = read(f)[0];
		local c = b;
		if newlines
			do
				if b == '\n'
				{
					do
						b = read(f)[0];
					while is_whitespace(b);
					c = '\n';
				}
			while b == '\n';
		if is_whitespace(b)
		{
			do
				b = read(f)[0];
			while is_whitespace(b);
			switch lastout
			  case ' ', '{', '}', '(', ')', '[', ']', ',', '.', ';', ':',
					'*', '/', '+', '-', '~', '^', '#', '=', '\'', '"'
				c = b;
			  default
			  {
				out.+ ' ';
				c = b;
			  }
		}
		else if b == '/'
		{
			b = read(f)[0];
			if b == '/'
			{
				do
					b = read(f)[0];
				until b == '\n';
				if newlines
					c = '\n';
				else if lastout == ' '
					c = nil;
				else
					c = ' ';
			}
			else if b == '*'
			{
				local last = nil;
				do
				{
					last = b;
					b = read(f)[0];
					if newlines
						if b == '\n'
							c = b;
				}
				until last == '*' and b == '/';
				if lastout == ' '
					c = nil;
				else
					c = ' ';
			}
			else
			{
				out.+ '/';
				c = b;
			}
		}
		else if b == '\''
		{
			do
			{
// Freaks out completely...!
				b = read(f)[0];
				out.+ b;
			} while b != '\'';
		}
		else if b == '"'
		{
			do
			{
				b = read(f)[0];
				out.+ b;
			} while b != '"';
		}
		if c != nil
		{
			out.+ c;
			lastout = c;
		}
	}
}

procedure usage(name)
{
	print(	"\n"
		"usage:    ", name, " <infilename> [<infilename> ...] [-stdout]\n"
		"          ", name, " -a [-r] [<inpath>] [-stdout]\n"
		"          ", name, " <infilename> -o <outfilename>\n"
		"\n"
		"   Switches:\n"
		"          -stdout  Write stripped output to standard output\n"
		"          -a       Strip all *.eel files in the current directory\n"
		"          -r       Recurse into subdirectories\n"
		"          -x       Output file extension [ess]\n"
		"\n"
		"   NOTE:  If no output file name, or -stdout, is specified, the output\n"
		"          is written to corresponding .eel files. (For example, the output\n"
		"          from 'name.eel' would be written to 'name.ess'.)\n"
		"\n"
	);
}

// Extract file extension from 'path'.
function getext(path)
{
	try
	{
		local p = path;
		for local i = sizeof p - 1, 0, -1
		{
			if p[i] == '.'
				return copy(p, i + 1, sizeof p - 1 - i);
		}
	}
	return nil;
}

//Return 'path' with file extension (if present) replaced by 'extension'.
function setext(path, extension)
{
	local s = path;
	for local i = sizeof path - 1, 0, -1
		if path[i] == '.'
		{
			s = copy(path, 0, i);
			break;
		}
	return s + "." + extension;
}

function is_dir(path)
{
	try
	{
		directory [path];
		return true;
	}
	return false;
}

function findfiles(list, path, recursive)
{
	local d = nil;
	try
		d = directory [path];
	except
	{
		print("ERROR: \"", path, "\" is not a directory, or could not be opened!\n");
		return false;
	}
	while true
	{
		local n = d:read();
		if not n
			break;
		if n == "." or n == ".."
			continue;
		local sp = path + "/" +  n;
		if is_dir(sp)
		{
			if recursive
				findfiles(list, sp, recursive);
		}
		else
		{
			if getext(n) != "eel"
				continue;
			list.+ path + "/" +  n;
		}
	}
	return true;
}

export function main<args>
{
	local all = false;
	local recursive = false;
	local infiles = [];
	local outfile = nil;
	local extension = "ess";

	tokentab = table [];
	for local i = 0, sizeof tokens - 1
		tokentab[tokens[i]] = i + ESS_FIRST_TOKEN;

	// Arguments
	for local i = 1, arguments - 1
		switch args[i]
		  case "-o"
		  {
			if not specified args[i + 1]
			{
				print("\nThe -o switch needs an argument!\n\n");
				usage(args[0]);
				return 1;
			}
			outfile = args[i + 1];
			i += 1;
		  }
		  case "-stdout"
			outfile = true;
		  case "-a"
			all = true;
		  case "-r"
			recursive = true;
		  case "-x"
		  {
			if not specified args[i + 1]
			{
				print("\nThe -x switch needs an argument!\n\n");
				usage(args[0]);
				return 1;
			}
			extension = args[i + 1];
			i += 1;
		  }
		  default
			infiles.+ args[i];
	if recursive and not all
	{
		print("ERROR: -r makes no sense without -a!\n");
		usage(args[0]);
		return 1;
	}
	if not sizeof infiles and not all
	{
		print("ERROR: No input files specified!\n");
		usage(args[0]);
		return 1;
	}
	if all and sizeof infiles > 1
	{
		print("ERROR: Input files specified along with -a!\n");
		usage(args[0]);
		return 1;
	}
	if all and typeof outfile == string
	{
		print("ERROR: Output file specified along with -a!\n");
		usage(args[0]);
		return 1;
	}

	if all
	{
		if sizeof infiles
			local inpath = infiles[0];
		else
			inpath = ".";
		if not findfiles(infiles, inpath, recursive)
		{
			print("Could not find input files! Aborting.\n");
			return 1;
		}
	}
	if not sizeof infiles
	{
		print("ERROR: No input files found!\n");
		usage(args[0]);
		return 1;
	}

	for local i = 0, sizeof infiles - 1
	{
		if outfile != true
			print("Stripping \"", infiles[i], "\"... ");

		// Process!
		local f = file [infiles[i], "rb"];
		local buf = dstring [];
		strip(f, buf, false);
		close(f);

		// Output
		if outfile == true
			print(buf);
		else
		{
			if outfile
				local ofn = outfile;
			else
				ofn = setext(infiles[i], "ess");
			print("Writing to \"", ofn, "\"... ");
			write(file [ofn, "wb"], buf);
		}
		if outfile != true
			print("OK!\n");
	}

	return 0;
}
